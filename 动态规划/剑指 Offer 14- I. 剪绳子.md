#### 题目
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。  
请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

#### 思路：  
对于的正整数 n，当 n≥2 时，可以拆分成至少两个正整数的和。令 i 是最后一个正整数，则剩下的部分是 n−i，n−i 可以不继续拆分，  
或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。

当 n≥2 时，假设对正整数 n 拆分出的最后一个正整数是 i（1≤i<n），则有以下两种方案：  

将 n 拆分成 i 和 n−i 的和，且 n−i 不再拆分成多个正整数，此时的乘积是 i×(n−i)；  
将 n 拆分成 i 和 n−i 的和，且 n−i 继续拆分成多个正整数，此时的乘积是 i×dp[n−i]。  

由于 i 的取值范围是 1 <= i < n，需要遍历所有的 i 得到 dp[x] 的最大值.因此可以得到状态转移方程如下：  
f(x) = max{f(x-i) * i, (x−i) * i}  ， i要取所有可能 1 <= i <n



```python
class Solution(object):
    def cuttingRope(self, n):
        """
        :type n: int
        :rtype: int
        """
        # 最后一段长：i， 范围可能：1 <= i <n
        # 设状态：f(x) =  长度为x的绳子，拆分后可能的最大乘积是多少
        # 转移方程：f(x) = max{f(x-i) * i, (x−i) * i}  遍历循环所有i，取最小值；
        # 注意点：前提是要：减断为m段（m>1），才能用此转移方程.
        # 边界条件： 0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。
        # if n==0 or n==1:
        #     return 0
        # if n==2:
        #     return 1
        # f[2] = 1
        # f[3] = 2

        f = [0] * (n+1)
        f[0] = f[1] = 0
        for x in range(2, n+1):
            f[x] = x-1
            # i的所有可能 1 <= i <n
            for i in range(1, n):
                f[x] = max(f[x], f[x-i] * i) # 分乘两段之后，继续剪断；只有继续减断，才能用此方程
                f[x] = max(f[x], (x-i) * i)  # 仅分成两段：x-i 和 i， 则max{(x-i) * i}
        return f[n]

```

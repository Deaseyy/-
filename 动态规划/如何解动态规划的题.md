# 动态规划题目特点

**动态规划：用于求解的个数 或 最优解**

**dfs ：用于 打印所有的解 的题目**

### 1.计数型

- 有多少种方式走到右下角

- 有多少种方法选出k个使得和是sum

### 2.求最大最小值

- 从左上角走到右下角路径的最大数字和
- 最长上升子序列长度

### 3.求存在性

- 取石子游戏，先手是否必胜
- 能不能选出k个数使得和是sum



# 动态规划组成部分

**例题1：Coin Change**   

你有三种硬币，分别面值2元，5元和7元，每种硬币都有足够多，买一本书需要27元，如何用最少的硬币组合正好付清，不需要对方找钱。



## 1.动态规划组成部分一：确定状态

- 解动态规划的时候需要开一个数组，数组的每个元素f[i] 或者 f[i] [j] 代表什么
  - 类似解数学题中的X,Y,Z
- 确定状态需要两个意识：
  - 最后一步
  - 子问题

### 最后一步(从哪里来)

- 虽然不知道最优策略是什么，但最优策略肯定是K枚硬币a<font size="1">1</font>, a<font size="1">2</font>,......,a<font size="1">k</font> 面值加起来是27
- 所以一定有**最后一枚**硬币：a<font size="1">k</font>
- 除掉这枚硬币，前面硬币的面值加起来是27-a<font size="1">k</font>

![image-20201121121404354](C:\Users\12395\AppData\Roaming\Typora\typora-user-images\image-20201121121404354.png)

> **关键点1**
>
> 我们不关心前面的k-1枚硬币是怎么拼出27-a<font size="1">k</font>的（可能有1种或100种拼法），而且我们现在甚至还不知道a<font size="1">k</font>和k，但是我们确定前面的硬币拼出了27-a<font size="1">k</font>

> **关键点2**
>
> 因为是最优策略，所以拼出27-a<font size="1">k</font>的硬币数一定要最少，否则这就不是最优策略了



### 子问题

- 此时我们要求：最少用多少枚硬币可以拼出 27-a<font size="1">k </font> （子问题）
- 原问题：最少用多少枚硬币可以拼出 27
- 我们将原问题转化成了一个子问题，而且规模更小：27-a<font size="1">k</font>

- **设置状态：f(x) = 最少用多少枚硬币可拼出x**



**具体分析**

最后那枚硬币a<font size="1">k</font>只可能是2，5，7

- 如果a<font size="1">k</font>是2，`f(27) = f(27-2) + 1` (加上最后这一枚硬币2)

- 如果a<font size="1">k</font>是5，`f(27) = f(27-5) + 1` (加上最后这一枚硬币5)

- 如果a<font size="1">k</font>是7，`f(27) = f(27-7) + 1` (加上最后这一枚硬币7)除此以外，没有其他可能性了。

需要求最少的硬币数，所以：

f(27) = min{f(27-2)+1, f(27-5)+1, f(27-7)+1}

注解：拼出27所需最少的硬币数 = 以上可能子问题中的最优解(最少个数)



## 2.动态规划组成部分二：状态转移方程

- 可以考虑 f(x) 从哪里来(上一步)，如，这里f(x) 来自 f(x-2) 或 f(x-5) 或 f(x-7)

- 设状态f[x] = 最少用多少枚硬币拼出x

- 对于任意x，

  **f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}**





## 3.动态规划组成部分三：初始条件和边界情况

- 两个问题：若 x-2，x-5， x-7 小于0怎么办？什么时候停下来？

- **如果不能拼出Y，就定义f[Y]=正无穷**     （边界情况：不要数组越界）

  - 例如 f[-1]=f[-2] =...= 正无穷
  - 所以f[1] = min{f[-1]+1, f[-4]+1, f[-6]+1} = 正无穷，表示拼不出来1

- **初始条件：f[0] = 0**     （初始条件）

  - 某些情况用转移方程算不出来，需要手工定义

    如，根据方程计算: f[0] = 正无穷，但明知它应该等于0

  - 计算f[1]本身也就是正无穷，f[2] 利用了f[0]=0, 计算结果为1

  - 得到结论：从0之后都可以由转移方程计算得到结果



## 4.动态规划组成部分四：计算顺序

### 计算顺序

大部分都是从小到大，二维就是从左到右，从上到下； 当然也有不一样的。

条件就是计算左边的f[x]时，右边的子问题结果得先计算出来；对于该例题：

- 开辟一个 `n+1` 长度的的数组f，用于保存结果

- **当我们计算得到f[x]时，f[x-2],  f[x-5],  f[x-7] 都已经得到结果了**  （判断计算顺序的一个依据）

- **拼出x所需要的最少硬币数：f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}**

- 初始条件：f[0] = 0
- 然后计算f[1],f[2],......,f[27]

- 循环对x 从小到大进行计算



### 结果分析

- 每一步尝试三种硬币，一共27步
- 与递归算法相比，没有任何重复计算
- 算法时间复杂度（即需要进行的步数）：27*3  （即n\*m）
- 递归时间复杂度：>> 27*3



# 动态规划解题总结

### 1. 解题步骤

动态规划组成部分 （以求最值型为例）：

1.确定状态

- 最后一步从哪里来 （最优策略中使用的最后一枚硬币a<font size="1">k</font>）
- 化成子问题（最少的硬币拼出27-a<font size="1">k</font>）

2.转移方程

  考虑 f(x) 从哪里来（上一步），比如，这里f(x) 来自 f(x-2) 或 f(x-5) 或 f(x-7)

  **最值型**：转化为多个子问题类型，取最值（max 或 min）

- f(27) = min{f(27-2)+1, f(27-5)+1, f(27-7)+1}  

  **计数型**：转化为多个子问题类型，方式种数相加

  **存在型**：OR 枚举各种可能

3.初始条件和边界情况

- f[0] = 0, 如果不能拼出Y，f[Y=正无穷

4.计算顺序

- 计算f[x]时，f[x-2],  f[x-5],  f[x-7] 都已得到结果

- 所以从小到大计算：f[0], f[1],f[2],......,f[n]



### 2. 代码实现

#### 动态规划代码实现

```java
// A：若干枚硬币（上面的2，5，7），M：支付的费用 （27）
public int coinChange(int[] A, int M){
	int[] f = new int[M+1]; // 开一个列表，保存每个子问题的结果
	int n = A.length;  // 硬币种类个数
	
    f[0] = 0; // 初始化
    int i, j;
    // 计算 f[1], f[2],......,f[n]
    for(i = 1; i <= M; ++i){
        f[i] = Integer.MAX_VALUE;  // 需要求f[i]的最小值，先设置一个无穷大值
        // 最后一枚 A[j]
        // f[i] = min{f[i-A[0]]+1,...,f[i-A[n-1]+1}
        for (j = 0; j<n; ++j){
            // 需要拼的值必须大于等于最后一枚面值；否则，就不会用到那个面值的硬币
            // 且在加上最后一枚之前，所拼的值必须也要能拼出来，否则正无穷+1还是正无穷；
            if (i >=A[j] && f[i-A[j]] != Integer.MAX_VALUE) {
                f[i] = Math.min(f[i-A[j]] + 1, f[i]);
            }
        }
    }
    if(f[M] == Integer.MAX_VALUE) {
        f[M] = -1;
    }
    return f[M];
}
```



#### 递归的解法

```java
int f(int x){
	if(x==0) return 0;
	int res = MAX_VALUE;
	if(x>=2){  // 最后一枚硬币是2元
		res = Math.min(f(x-2) + 1, res)
	}
	if(x>=5){  // 最后一枚硬币是5元
		res = Math.min(f(x-5) + 1, res)
	}
	if(x>=7){ // 最后一枚硬币是7元
		res = Math.min(f(x-7) + 1, res)
	}
	return res
}
```

**递归执行图：**

![image-20201121115719238](C:\Users\12395\AppData\Roaming\Typora\typora-user-images\image-20201121115719238.png)



### 3. 动态规划代码模板

```
1. 开辟数组f，用于保存每一步计算结果
2. 初始化数组f
3. 根据转移方程: 循环计算 f[1], f[2],......,f[n]
4. 计算时需要排除边界情况
5. 返回f[n] 作为解题结果
```



# 动态规划题型

### 1. 最优解 （求最值）

**上面的例题1：Coin Change**   



### 2. 计数型（求方式数）

**例题2：Unique Paths**

给定m行n列的网格，有一个机器人从左上角(0,0)出发，每一步可以向下或者向右走一步，问有多少种不同的方式走到右下角。

#### 步骤1： 确定状态

**最后一步**：无论机器人用何种方式到达右下角，总有最后挪动的一步：向右或向下

- 右下角设为（m-1，n-1），那么前一步一定在（m-2，n-1）或（m-1，n-2）

**子问题：**如果有X种方式从左上角走到（m-2，n-1），有Y种方式从左上角走到（m-1，n-2）；则有X+Y种方式走到右下角（m-1，n-1）

- 问题转化为：机器人有多少种方式从左上角走到（m-2，n-1）和（m-1，n-2）

- 原问题为：有多少种方式从左上角走到（m-1，n-1）

**状态：**设 `f[i][j]` 为机器人有多少种方式从左上角走到（i, j）



#### 步骤2：写转移方程

**转移方程：** 对于任意一个格子（i，j）有：`f[i][j] = f[i-1][j] + f[i][j-1]`

- 方程注解：走到（i，j）的种数 = 走到（i-1，j）的种数 + 走到（i，j-1）的种数 



#### 步骤3：初始条件和边界条件

**初始条件：**`f[0][0] = 1`，因为机器人只有一种方式到左上角，就是不动

**边界情况：**当i = 0 或 j = 0，则前一步只能从一个方向过来，所以从左上角走到这些格子的方式种数就是1，直接赋值：`f[i][j] = 1` 



#### 步骤4：计算顺序

- 此题需要开辟一个 `M*N` 的二维数组，用于保存结果

- `f[0][0] = 1`

- 计算第0行：`f[0][0], f[0][1], ......, f[0][n-1]`
- 计算第1行：`f[1][0], f[1][1], ......, f[1][n-1]`
- ......
- 计算第m-1行：`f[m-1][0], f[m-1][1], ......, f[m-1][n-1]`

- 答案就是：`f[m-1][n-1]`



#### 结论分析

时间复杂度（计算步数）：O(MN)，空间复杂度(数组大小)：O(MN)



#### 代码实现

```java
public int uniquePaths(int m, int n){
	int[][] f = new int[m][n];
	int i,j;
	for(i=0; i < m; ++i){
		for (j = 0; j < n; j++){
			if(i == 0 || j == 0){
				f[i][j] = 1;  // 这里选择在里面初始化，因为for循环对每个格子都走了一遍
			}else{
				f[i][j] = f[i-1][j] + f[i][j-1];
			}
		}
	}
	return f[m-1][n-1];
}
```



### 3. 存在型（求是否存在 或 是否可行）

**例题3：Jump Game**

有 n 块石头分别在 x 轴的0，1，......, n-1 位置，一只青蛙在石头0，想跳到石头 n-1，如果青蛙在第 i 块石头上，它最多可以向右跳距离a<font size="1.5">i</font>，问青蛙能否跳到石头n-1。

用例：

输入：a=[2,3,1,1,4]，输出：True

输入：a=[3,2,1,0,4]，输出：False

#### 步骤1：确定状态

**最后一步：**如果青蛙能够跳到最后一块石头 n-1，我们考虑它跳的最后一步：

- 这一步是从石头 i 跳过来的，` i < n-1`

- 这需要同时满足两个条件：
  - 青蛙可以跳到石头 i，（不能判断）
  - 石头i 能够跳跃的最大距离 >= 最后一步距离 ：a<font size="1.5">i</font>  >= n-1 - i ，（可以判断），否则根本跳不到最后一块石头上 

**子问题：** 此时，问题转化为：需要知道青蛙能不能跳到石头 i （i < n-1）

- 原问题是：青蛙能不能跳到石头 n-1

**状态：** 设 f[j] 表示青蛙能不能跳到石头 j



#### 步骤2：写转移方程

**转移方程：** 需要枚举上一个跳到的石头 i （0 <= i < j），并且 `f[i]` 和 `i + a[i] >= j` 两个条件必须同时满足。

- 方程为：f[j] = OR<font size='1'>0<=i<j</font>(f[i] AND i + a[i] >= j)

![image-20201121234010640](C:\Users\12395\AppData\Roaming\Typora\typora-user-images\image-20201121234010640.png)

注解：`OR` 表示：for循环时，只要有一个 i 满足后面两个条件，则是True，否则就是False；`AND`：表示两个条件同时满足。



#### 步骤3：初始条件和边界条件

**初始条件：**f[0] = True，因为青蛙一开始就在石头0

**边界条件：** 我们枚举的那些情况(0 <= i < j)都不会越界，所以没有边界条件



#### 步骤4：计算顺序

- f[j] 表示青蛙能不能跳到石头 j
- 初始化 f[0] = True
- 计算 f[1], f[2], ......, f[n-1]
- 答案就是 f[n-1]



#### 结果分析

时间复杂度：O(N2)，空间复杂度（数组大小）：O(N)



#### 代码实现

```java
public boolean canJump(int[] A){
    int n = A.length;
    boolean[] f = new boolean[n];
    f[0] = true; // 初始化f[j]

    for(int j = 1; j < n; ++j){
        f[j] = false;
        // 枚举i(上一步)的所有可能 (0 <= i < j)
        // 最后一步是从i跳到j
        for(int i=0; i < j; ++i){
	    if(f[i] && i + A[i] >= j){
	        f[j] = true; // 只要有一个i满足以上两个条件，就为True
	        break;
	    }
        }
    }
    return f[n - 1]
}
```



# 动态规划常见类型

- 坐标型
- 序列型
- 划分型
- 区间型
- 背包型
- 最长序列型
- 博弈型
- 综合型



# 做过的例题

### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```python
class Solution(object):
    def lengthOfLIS(self, nums):
        """动态规划解法"""
        # 设置状态：f(i) = 以a[i]结尾的最长上升子序列的长度
        # f[i]从哪来: 可以由a[i]前面每一个比它小的a[j]计算出的f[j]得来,即a[i]>a[j]；
        # 转移方程：f[i] = max{f[j]} + 1； 取f[j]最大值 + a[i]本身长度1
        n = len(nums)
        if n == 0:
            return 0

        f = [0] * n
        f[0] = 1 # 初始化；它本身，长度为1
        res = 1
        for i in range(1, n):
            f[i] = 1
            # 枚举i前面每个比a[i]小的a[j]，取最大的f[j]
            for j in range(i):
                if nums[i] > nums[j]:
                    f[i] = max(f[j]+1, f[i])
            res = max(res, f[i])  # （f[i]为以某个值结尾的最长子序列），需取最大值
        return res
```



待续。。。。。。



